
Spring interview questions


1. Types of Bean Scope in Spring
Spring provides the following bean scopes:
Scope	Description
singleton	Default. Only one instance is created per Spring container.
prototype	A new instance is created every time the bean is requested.
request	One bean instance per HTTP request (Web-aware Spring applications only).
session	One bean instance per HTTP session (Web-aware Spring apps).
application	One bean instance per ServletContext.
websocket	Scoped to a WebSocket lifecycle.


2. @Autowired, @Inject, @Component, and @Bean
· 
@Autowired: Spring annotation used for dependency injection.
· 
@Autowired
private MyService myService;
· 
@Inject: From javax.inject. Works like @Autowired but not Spring-specific.
· 
@Inject
private MyService myService;
· 
@Component: Marks a Java class as a Spring-managed component.
· 
@Component
public class MyService {}
· 
@Bean: Used to define a bean explicitly inside a @Configuration class.
· 
@Bean
public MyService myService() {
    return new MyService();
}



3. ✅ What’s the Difference Between @Primary and @Qualifier?

Annotation	Purpose	When to Use
@Primary	Tells Spring to use this bean by default	When you want to mark one default
@Qualifier	Specifies exact bean to inject	When multiple beans exist, choose one
· 
@Primary: Used when multiple beans of the same type exist. Spring uses the primary bean unless another is specified.
· 
@Primary
@Bean
public MyService primaryService() {
    return new MyService();
}
· 
@Qualifier: Used to tell Spring which bean to inject.
· 
@Autowired
@Qualifier("secondaryService")
private MyService myService;




4. Types of IoC Containers
Container	Description
BeanFactory	Basic container, lazy loading.
ApplicationContext	Advanced container, supports annotations, events.
Use ApplicationContext in real-world apps for full features.



5. What is a Stereotype Annotation?
Stereotype annotations are meta-annotations that define components in Spring:
· 
@Component ,@Service,@Repository , @Controller

They tell Spring to auto-detect and register the beans.


6. Spring MVC Workflow
1. 
Client sends a request to DispatcherServlet.
2. 
3. 
DispatcherServlet consults HandlerMapping to find the controller.
4. 
5. 
Controller processes the request and returns ModelAndView.
6. 
7. 
DispatcherServlet uses ViewResolver to resolve the view.
8. 
9. 
The view is rendered and returned to the client.
10. 
Client → DispatcherServlet → Controller → ViewResolver → View → Client



7. Spring Bean vs Java Bean
Feature	Java Bean	Spring Bean
Definition	POJO with getter/setters	Managed by Spring Container
Instantiation	Via new keyword	Via Spring IoC
Scope	No scope	Multiple scopes supported


8. SOLID Principles in Java (OOP)
✅ SOLID Principles (OOP Best Practices)
Letter	Principle	Meaning
S	Single Responsibility Principle	One class → one reason to change
O	Open/Closed Principle	Open for extension, closed for modification
L	Liskov Substitution Principle	Subtypes should replace base types safely
I	Interface Segregation Principle	No forced methods; use smaller interfaces
D	Dependency Inversion Principle	Depend on abstractions, not concrete classes
🔹 1. Single Responsibility Principle (SRP)
📌 A class should have only one reason to change.
❌ Bad Example:
class User {
    void saveToDatabase() { /* Save logic */ }
    void sendEmail() { /* Email logic */ }
}
✅ Good Example:
class User {
    private String name;
    // Only user data
}

class UserRepository {
    void save(User user) {
        // Save to DB
    }
}

class EmailService {
    void sendWelcomeEmail(User user) {
        // Send email
    }
}

🔹 2. Open/Closed Principle (OCP)
📌 Classes should be open for extension, but closed for modification.
❌ Bad Example:
class Discount {
    double calculate(String type, double amount) {
        if (type.equals("FESTIVAL")) return amount * 0.9;
        if (type.equals("REGULAR")) return amount * 0.95;
        return amount;
    }
}
✅ Good Example (use polymorphism):
interface Discount {
    double apply(double amount);
}

class FestivalDiscount implements Discount {
    public double apply(double amount) { return amount * 0.9; }
}

class RegularDiscount implements Discount {
    public double apply(double amount) { return amount * 0.95; }
}

🔹 3. Liskov Substitution Principle (LSP)
📌 Subclasses should be substitutable for their parent classes.
❌ Bad Example:
class Bird {
    void fly() { }
}

class Ostrich extends Bird {
    void fly() { throw new UnsupportedOperationException(); }
}
✅ Good Example:
interface Bird { }

interface FlyingBird extends Bird {
    void fly();
}

class Parrot implements FlyingBird {
    public void fly() { System.out.println("Flying"); }
}

class Ostrich implements Bird {
    // No fly method — safe!
}

🔹 4. Interface Segregation Principle (ISP)
📌 Don’t force a class to implement methods it doesn’t need.
❌ Bad Example:
interface Worker {
    void work();
    void eat();
}

class Robot implements Worker {
    public void work() { }
    public void eat() { } // Not applicable!
}
✅ Good Example:
interface Workable {
    void work();
}

interface Eatable {
    void eat();
}

class Human implements Workable, Eatable {
    public void work() { }
    public void eat() { }
}

class Robot implements Workable {
    public void work() { }
}

🔹 5. Dependency Inversion Principle (DIP)
📌 High-level modules should not depend on low-level modules; both should depend on abstractions.
❌ Bad Example:
class MySQLDatabase {
    void connect() { }
}

class UserService {
    MySQLDatabase db = new MySQLDatabase();
}
✅ Good Example:
interface Database {
    void connect();
}

class MySQLDatabase implements Database {
    public void connect() { }
}

class UserService {
    private Database db;

    UserService(Database db) {
        this.db = db;
    }
}
9. Spring AOP (Aspect-Oriented Programming)
AOP separates cross-cutting concerns (like logging, security, etc.) from business logic.
· 
Aspect: A concern like logging.
· 
· 
Join Point: A point in execution, like method call.
· 
· 
Advice: Code executed at a join point.
· 
· 
Pointcut: Expression that selects join points.
· 
· 
Weaving: Linking aspects to target objects.
· 
Example:
@Aspect
@Component
public class LoggingAspect {
    @Before("execution(* com.example.service.*.*(..))")
    public void logBefore(JoinPoint joinPoint) {
        System.out.println("Before Method: " + joinPoint.getSignature());
    }
}


[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[                  {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{                    }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]                     ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]



�� Spring Boot Interview Questions and Answers
✅ 1. Easy Level Questions
1. What is Spring Boot?
Spring Boot is a framework built on top of Spring that simplifies the development of production-ready Spring applications by providing auto-configuration, embedded servers, and minimal boilerplate code.
Key Points:
· 
Rapid development
· 
· 
No XML configuration
· 
· 
Embedded Tomcat/Jetty/Undertow
· 
· 
Microservice-ready
· 
2. What are the advantages of using Spring Boot?
· 
Auto-configuration
· 
· 
Embedded servers
· 
· 
Minimal setup
· 
· 
Production-ready with Actuator
· 
· 
Easy integration with Spring Cloud
· 
3. How is Spring Boot different from Spring?
Feature	Spring Framework	Spring Boot
Setup	Manual configuration (XML or Java-based)	Auto-configuration, no XML
Dependencies	Add individually	Comes with embedded dependencies
Web Server	Requires external (like Tomcat)	Has embedded servers like Tomcat, Jetty
Entry Point	No standard entry point	Uses main() method (auto-run)
Complexity	More boilerplate	Rapid development, less boilerplate
Use Case	For full control over every config	For fast microservice development

4. What is the role of @SpringBootApplication?
It’s a combination of:
· 
@Configuration
· 
· 
@EnableAutoConfiguration
· 
· 
@ComponentScan
· 
5. What is an embedded server in Spring Boot?
A web server (like Tomcat) embedded in the app, removing the need to deploy .war files.
@SpringBootApplication
public class DemoApp {
  public static void main(String[] args) {
    SpringApplication.run(DemoApp.class, args);
  }
}
6. Purpose of application.properties or application.yml
Used for configuring application behavior:
server.port=8081
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
7. What is a spring-boot-starter?
A set of dependencies for a specific functionality:
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-web</artifactId>
</dependency>
8. How do you run a Spring Boot application?
· 
Via main() method
· 
· 
Using mvn spring-boot:run
· 
· 
Executing the jar file: java -jar app.jar
· 
9. What is Spring Boot Actuator?
Provides production-ready features like health checks, metrics, info, etc.
<dependency>
  <groupId>org.springframework.boot</groupId>
  <artifactId>spring-boot-starter-actuator</artifactId>
</dependency>
10. Difference between CrudRepository and JpaRepository
Feature	CrudRepository	JpaRepository
Basic CRUD	✅	✅
Pagination	❌	✅
Flush control	❌	✅


⚙️ 2. Medium Level Questions
11. What is auto-configuration?
Spring Boot automatically configures beans based on the classpath and your configurations.
12. What are Spring Boot profiles?
Allow you to define multiple environments:
# application-dev.properties
server.port=8081
@Profile("dev")
@Bean
public DataSource devDataSource() {
   return new HikariDataSource();
}
13. How does Spring Boot handle logging?
· 
Uses SLF4J with Logback by default
· 
· 
Configurable via application.properties
· 
14. Difference between @RestController and @Controller
Annotation	Description
@RestController	Returns JSON/XML by default
@Controller	Used with Thymeleaf/JSP views
15. What is Spring Boot DevTools?
· 
Auto reload on code changes
· 
· 
LiveReload support
· 
16. How to configure DB?
spring.datasource.url=jdbc:mysql://localhost:3306/mydb
spring.datasource.username=root
17. Role of @EnableAutoConfiguration
Tells Spring Boot to configure beans based on classpath contents.
18. How to create a custom starter?
Create a library with spring.factories pointing to AutoConfiguration class.
19. Embedded Tomcat Server
· 
Spring Boot includes Tomcat internally by default.
· 
20. Validation in Spring Boot
Use @Valid or @Validated:
@PostMapping("/user")
public ResponseEntity<?> saveUser(@Valid @RequestBody User user) {
}



�� 3. Hard Level Questions
21. Spring Security Handling
· 
Use spring-boot-starter-security
· 
· 
Override via custom config class
· 
22. Externalized Configuration
· 
YAML, properties, environment variables, or Config Server
· 
23. Spring Boot + JPA
· 
Use spring-boot-starter-data-jpa
· 
· 
Define @Entity classes and repository interfaces
· 
24. Managing App Versions
Use versioning in pom.xml and tools like Docker tags or Helm charts.
25. Actuator Endpoints
· 
/actuator/health, /metrics, /info
· 
· 
Secure with Spring Security
· 
26. What Is Custom Error Handling in Spring Boot?
Spring Boot provides a default error response (/error), but for better control, we often define our own:
* Custom error messages
* Friendly JSON structure
* Centralized exception handling

🔹 Use Case:
“When an exception occurs (like resource not found), I want to return a clean and meaningful error message instead of the default HTML or stack trace.”

🛠️ Step-by-Step: Custom Error Handling
✅ 1. Create a Custom Exception
public class UserNotFoundException extends RuntimeException {
    public UserNotFoundException(String message) {
        super(message);
    }
}

✅ 2. Create a Global Exception Handler
@RestControllerAdvice
public class GlobalExceptionHandler {

    @ExceptionHandler(UserNotFoundException.class)
    public ResponseEntity<String> handleUserNotFound(UserNotFoundException ex) {
        return new ResponseEntity<>(ex.getMessage(), HttpStatus.NOT_FOUND);
    }

    @ExceptionHandler(Exception.class)
    public ResponseEntity<String> handleGenericException(Exception ex) {
        return new ResponseEntity<>("Something went wrong!", HttpStatus.INTERNAL_SERVER_ERROR);
    }
}
@RestControllerAdvice = Applies to all controllers @ExceptionHandler = Handles specific exceptions

✅ 3. Use in Controller
@RestController
@RequestMapping("/users")
public class UserController {

    @GetMapping("/{id}")
    public String getUser(@PathVariable int id) {
        if (id != 1) {
            throw new UserNotFoundException("User with ID " + id + " not found");
        }
        return "User found";
    }
}

🧪 Sample Output
If you hit /users/2, you'll get:
{
  "message": "User with ID 2 not found"
}

🗣️ Interview Summary:
“We use @RestControllerAdvice and @ExceptionHandler to define centralized, clean error responses. This improves API consistency and makes debugging easier.”

27. Deploy to Production
· 
Build jar with Maven/Gradle
· 
· 
Use Docker/Kubernetes or push to cloud (AWS, GCP, etc.)
· 
28. Transaction Handling
@Transactional
public void updateData() {
  // code
}
29. Spring Boot Testing
· 
@SpringBootTest
· 
· 
@DataJpaTest
· 
· 
@WebMvcTest
· 
30. @SpringBootTest vs @WebMvcTest
Annotation	Loads Beans
SpringBootTest	All application context
WebMvcTest	Only controller-related beans
31. Async Support
Use @EnableAsync and @Async



�� 4. Advanced Level Questions
32. Config for Microservices
· 
Use Spring Cloud + Config Server
· 
· 
Eureka/Consul for discovery
· 
33. Circuit Breaker
· 
Use Resilience4j or Hystrix
· 
@CircuitBreaker(name="myService", fallbackMethod="fallback")
public String callService() {...}
34. Docker Support
· 
Add Dockerfile
· 
FROM openjdk:17
COPY target/app.jar app.jar
ENTRYPOINT ["java", "-jar", "app.jar"]
35. Distributed Tracing
· 
Use Spring Cloud Sleuth + Zipkin
· 
36. Monitoring Support
· 
Actuator + Micrometer + Prometheus/Grafana
· 
37. Background Tasks
Use @Scheduled for periodic tasks
38. Large-scale Config
· 
Split configs by profile
· 
· 
Use centralized config management
· 
39. Multi-tenancy
· 
Use Hibernate multi-tenancy with tenant resolver
· 
40. Stateless State Management
· 
Use tokens (JWT)
· 
· 
Store user session in DB or Redis
· 



Let me know if you'd like:
· 
All content in a printable PDF
· 
· 
Visual diagrams for microservice architecture
· 
· 
Practice questions for each level
· 
 
 
Got it! I’ll prepare a comprehensive, well-structured, and interview-focused answer sheet for all your microservices questions from easy to advanced level.
Each answer will include:
· 
Clear explanations
· 
· 
Real-world examples
· 
· 
Best practices
· 
· 
Diagrams or code snippets where applicable
· 
· 
Interview tips
· 
I’ll organize it in a clean, easy-to-study format with comparison tables and practical points.
Give me a moment, and I’ll deliver a detailed Microservices Interview Q&A document for you.
✅ Stateless vs State Management – Simple Explanation
In software development, especially in web and distributed systems, statelessness and state management are critical concepts that define how data (state) is handled between client and server or components.

🔹 What is Stateless?
A stateless system does not store any information about the previous requests or interactions.
Each request is independent, and the server treats it as a new interaction every time.
🔸 Example: HTTP is Stateless
When you send a request to a web server:
GET /user/123
The server doesn't remember anything about your last request. It only responds based on the current request.
✅ Advantages of Stateless Systems:
* ✅ Scalable (easy to distribute across servers)
* ✅ Simple to implement and debug
* ✅ No session memory on the server
❌ Disadvantages:
* ❌ Must send all necessary data with every request
* ❌ No built-in session memory (you need tokens, headers, etc.)

🔹 What is Stateful (State Management)?
A stateful system remembers information across requests.
State is stored somewhere (client, server, or external store like Redis or DB).
🔸 Example: Logged-in Session
* You log in → server creates a session
* Next request → server remembers who you are (using session ID, cookie, or token)

🔹 State Management Types
Type	Description	Example
Client-side	State stored on the browser/client	LocalStorage, Cookies
Server-side	Server keeps session info (e.g., user login)	HttpSession, Spring Session
Token-based (stateless)	Client stores token; server validates it on each request	JWT, OAuth2
External store	State saved in DB or cache (Redis, Memcached)	Shared sessions
✅ Example: Stateless vs Stateful in Java
🔸 Stateless Controller (Spring Boot)
@RestController
public class HelloController {
    @GetMapping("/hello")
    public String hello(@RequestParam String name) {
        return "Hello, " + name; // Stateless – no memory of previous call
    }
}
🔸 Stateful Controller (Session)
@RestController
@SessionAttributes("name")
public class UserController {
    @PostMapping("/login")
    public String login(@RequestParam String name, Model model) {
        model.addAttribute("name", name); // State is stored in session
        return "Logged in";
    }

    @GetMapping("/dashboard")
    public String dashboard(@ModelAttribute("name") String name) {
        return "Welcome back, " + name;
    }
}

🧠 In Summary
Concept	Stateless	Stateful
Memory	No memory between calls	Remembers previous state
Scalability	Highly scalable	Less scalable
Common in	REST APIs, Microservices	Sessions, Chat apps, Games
Tools/Examples	HTTP, JWT, REST	Session, Cookies, Spring Session
Let me know if you'd like a diagram, or how this applies in Spring Boot, REST API, or React/Angular frontend apps.

[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[                  {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{                    }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]                     ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]



[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[[                  {{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{{                    }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}]                     ]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]]






Microservices Interview Questions & Answers



Easy Level
1. What is a microservice architecture?
Microservice architecture is a design approach where an application is composed of small, loosely coupled, independently deployable services that perform specific business functions.
Example: An e-commerce app has separate microservices for user management, orders, payment, and inventory.



2. What are the benefits of microservices?
· 
Scalability: Scale individual services independently.
· 
· 
Flexibility: Use different technologies for different services.
· 
· 
Resilience: Fault isolation; one failing service doesn’t bring down the system.
· 
· 
Faster deployment: Smaller codebases, faster releases.
· 
· 
Organizational alignment: Teams can own specific services.
· 



3. What are the key characteristics of microservices?
· 
Independently deployable
· 
· 
Decentralized data management
· 
· 
Technology diversity allowed
· 
· 
Lightweight communication protocols (usually HTTP/REST or messaging)
· 
· 
Business capability-oriented
· 



4. How does microservice architecture differ from monolithic architecture?
Aspect	Monolithic	Microservices
Deployment	Single unit	Independent services
Scalability	Whole app scaled	Scale individual services
Technology	One tech stack	Polyglot (multiple techs)
Fault Tolerance	Single failure can stop system	Fault isolation between services


5. What is service discovery in microservices architecture?
Service discovery helps microservices find each other dynamically at runtime instead of using fixed URLs.
How? Usually via a registry like Eureka, Consul, or ZooKeeper.



6. What is an API Gateway in a microservices architecture?
An API Gateway acts as a single entry point for clients, routing requests to the appropriate microservices. It can handle cross-cutting concerns like authentication, rate limiting, and load balancing.



7. What are some common communication patterns between microservices?
· 
Synchronous HTTP/REST calls
· 
· 
Asynchronous messaging via message brokers (Kafka, RabbitMQ)
· 
· 
gRPC or RPC calls
· 



8. How do microservices communicate with each other?
Usually via HTTP REST APIs or asynchronous messaging systems. Choice depends on use case and latency requirements.



9. What are the typical technologies used in a microservices architecture?
· 
Containerization: Docker
· 
Orchestration: Kubernetes
· 
Service Discovery: Eureka, Consul
· 
Messaging: Kafka, RabbitMQ
· 
· 
API Gateway: Zuul, Kong
· 
· 
Monitoring: Prometheus, Grafana
· 

10. What is Docker and how is it used in microservices?
Docker packages services into containers with all dependencies, making deployments consistent and portable.



Medium Level
11. What is a 12-factor app?
A methodology for building SaaS apps with best practices like externalized config, stateless processes, and continuous deployment.



12. What is the role of Kubernetes in microservices?
Kubernetes orchestrates containerized microservices by managing deployment, scaling, and networking.



13. How do you handle transaction management in microservices?
Use sagas for distributed transactions or design services to be eventually consistent.



14. What is the Circuit Breaker pattern in microservices?
It prevents cascading failures by stopping calls to a failing service temporarily.



15. How do you secure microservices?
Use OAuth2, JWT tokens
· 
API Gateway for centralized auth
· 
Mutual TLS for service-to-service auth

16. How do you manage the state in microservices?
Prefer stateless services with external session stores like Redis or databases.


17. What is the role of event-driven architecture in microservices?
Allows services to communicate asynchronously via events, improving decoupling and scalability.



18. Difference between synchronous and asynchronous communication?
Synchronous	Asynchronous
Request/Response	Event-driven, message-based
Tightly coupled	Loosely coupled
Higher latency risk	More resilient


19. What is Spring Cloud and how does it help?
Spring Cloud provides tools for service discovery, config management, circuit breakers, and more to simplify microservices development.



20. How would you handle logging and monitoring?
Centralized logging (ELK stack), distributed tracing (Zipkin, Jaeger), and metrics collection (Prometheus).



Hard Level
21. How do you implement resilience?
Use retries, timeouts, circuit breakers, fallback methods, and bulkheads.



22. What is the Saga pattern?
A sequence of local transactions coordinated via events or orchestration to maintain data consistency.



23. How do you implement eventual consistency?
Allow temporary data inconsistencies with compensating transactions and event-driven updates.



24. Role of message broker?
Facilitates asynchronous communication and decoupling.



25. How do you handle database management?
Each microservice owns its database (database per service) to ensure decoupling.



26. How does microservices support continuous delivery?
Small deployable units enable fast, independent releases.



27. What is the Strangler Fig pattern?
Gradually replace parts of a monolith with microservices.



28. Challenges and mitigation?
· 
Distributed complexity → use service mesh
· 
· 
Data consistency → eventual consistency
· 
· 
Monitoring → centralized observability tools
· 



29. Role of API Gateway and API versioning?
Gateway routes requests and manages versioning by URL, headers, or params.



30. Service-to-service authentication?
Use mutual TLS or token-based mechanisms like JWT.



Advanced Level
31. Cross-cutting concerns handling?
Use API Gateway, service mesh (Istio), and sidecar proxies for logging, security, and monitoring.



32. Best practices for testing?
Unit, integration, contract testing; use testcontainers for dependencies.



33. Role of service mesh?
Manages service-to-service communication, security, and observability transparently.



34. Service versioning implementation?
Via API Gateway, semantic versioning, or separate deployment units.



35. Data synchronization?
Event sourcing or change data capture (CDC).



36. Kubernetes support?
Auto-scaling, service discovery, rolling updates.



37. Configuration management?
External config servers like Spring Cloud Config or Consul.



38. Security strategy difference?
Monolith: centralized security. Microservices: decentralized, with multiple entry points.



39. Dependencies and orchestration?
Use orchestration tools, choreography, or workflow engines.



40. Scaling microservices?
Horizontal scaling, autoscaling groups, and load balancing.



If you want, I can provide the full formatted document with code snippets, diagrams, and practical examples for each question. Would you like that?
Certainly! Here's a structured, detailed, and interview-focused explanation for each Spring Security question across Easy, Medium, Hard, and Advanced levels. The answers include concise theory, real-world examples, code snippets, and best practices for easy studying and interview prep.



Spring Security Interview Questions & Answers



Easy Level
1. What is Spring Security?
Spring Security is a powerful, customizable framework that provides authentication, authorization, and other security features to Java applications, especially Spring-based.



2. What are the main features of Spring Security?
· 
Authentication & Authorization
· 
· 
Protection against common attacks (CSRF, session fixation)
· 
· 
LDAP integration
· 
· 
OAuth2 support
· 
· 
Method-level security annotations
· 
· 
Password encoding & hashing
· 

3. What is authentication and authorization in Spring Security?
· 
Authentication: Verifying user identity (login)
· 
· 
Authorization: Controlling access to resources based on roles or permissions
· 

4. What is the default login page in Spring Security?
A simple login form provided by Spring Security when no custom login page is configured.



5. What are some common authentication mechanisms used in Spring Security?
· 
Form-based login
· 
· 
HTTP Basic Authentication
· 
· 
LDAP Authentication
· 
· 
OAuth2 / OpenID Connect
· 
· 
JWT (JSON Web Tokens)
· 



6. What is the @Secured annotation in Spring Security?
Used to specify method-level security by restricting access to methods based on roles.
@Secured("ROLE_ADMIN")
public void adminOnlyMethod() { }



7. What is the purpose of the SecurityConfigurerAdapter class?
It’s a base class used to configure various aspects of Spring Security (HTTP security, authentication providers, etc.) by extending it.



8. How do you disable Spring Security’s default login page?
By configuring a custom login page in the security configuration:
http.formLogin().loginPage("/custom-login").permitAll();



9. What is the UserDetailsService in Spring Security?
An interface used to load user-specific data during authentication. You implement it to fetch users from a database.
public class CustomUserDetailsService implements UserDetailsService {
    public UserDetails loadUserByUsername(String username) {
        // fetch user from DB and return UserDetails
    }
}



10. What is the BCryptPasswordEncoder?
A password encoder that uses the BCrypt hashing function to securely hash passwords.
@Bean
public PasswordEncoder passwordEncoder() {
    return new BCryptPasswordEncoder();
}



Medium Level
11. What is a SecurityContext in Spring Security?
Holds the currently authenticated user's details, stored in a thread-local storage, accessed during a request.



12. What is CSRF protection in Spring Security?
Cross-Site Request Forgery protection prevents unauthorized commands from being transmitted from a user that the web application trusts.
Spring Security enables CSRF protection by default on state-changing methods.



13. How do you configure HTTP security in Spring Security?
By overriding configure(HttpSecurity http) in a class extending WebSecurityConfigurerAdapter:
@Override
protected void configure(HttpSecurity http) throws Exception {
    http.authorizeRequests()
        .antMatchers("/admin/**").hasRole("ADMIN")
        .anyRequest().authenticated()
        .and()
        .formLogin();
}



14. What is the role of AuthenticationManager?
It handles the authentication process by verifying credentials and returning an Authentication object if successful.



15. How does Spring Security handle form-based authentication?
Spring Security intercepts the login POST request, authenticates credentials via the AuthenticationManager, and redirects accordingly.



16. How can you configure multiple authentication providers?
By registering multiple AuthenticationProvider beans in the AuthenticationManagerBuilder:
auth.authenticationProvider(daoAuthenticationProvider());
auth.authenticationProvider(ldapAuthenticationProvider());



17. What is @PreAuthorize and @PostAuthorize?
Annotations for method-level security based on SpEL expressions, executed before or after the method invocation.
@PreAuthorize("hasRole('ADMIN')")
public void secureMethod() { }



18. What are filters in Spring Security?
Filters intercept requests to perform security logic (authentication, authorization, etc.) arranged in a filter chain.



19. How does Spring Security integrate with OAuth2?
Supports OAuth2 login by configuring oauth2Login() in HTTP security, enabling login via Google, Facebook, etc.



20. Difference between formLogin() and httpBasic()?
· 
formLogin(): Presents an HTML login form
· 
· 
httpBasic(): Uses HTTP headers for authentication, typically for APIs
· 



Hard Level
21. How does Spring Security support method-level security?
Using annotations like @Secured, @PreAuthorize, @PostAuthorize along with enabling method security via @EnableGlobalMethodSecurity.



22. How does Spring Security handle session management?
Configurable session creation policy, concurrency control, and protection against session fixation attacks.



23. What is Remember-Me functionality?
Allows users to remain logged in over sessions using cookies.



24. How do you configure OAuth2 authentication?
By setting up client registrations in application.properties and enabling oauth2Login().



25. What is LDAP authentication?
LDAP is a protocol for accessing directory services. Spring Security supports authenticating users against an LDAP server.



26. What is AccessDecisionManager?
Decides whether a user has access to a secured resource based on votes from multiple AccessDecisionVoters.



27. How does Spring Security prevent session fixation?
By creating a new session ID on authentication success (SessionFixationProtectionStrategy).



28. How does Spring Security support JWT?
By implementing filters to validate JWT tokens in request headers and set the authentication context.



29. What is SecurityContextPersistenceFilter?
Stores and retrieves the SecurityContext from the session between requests.



30. How would you implement two-factor authentication?
Add an additional step after password authentication, e.g., sending a code via SMS and verifying it before granting access.



Advanced Level
31. How to implement Single Sign-On (SSO)?
Using OAuth2/OIDC providers or SAML with Spring Security extensions.



32. How can you secure RESTful APIs?
Use JWT tokens, stateless sessions, and configure HTTP Basic or OAuth2 with appropriate CORS and CSRF settings.



33. How does Spring Security support Role Hierarchy?
By defining role inheritance in a RoleHierarchy bean, allowing roles to implicitly have permissions of other roles.



34. What is DelegatingAuthenticationManager?
An AuthenticationManager that delegates authentication to a chain of managers.



35. How does Spring Security integrate with Spring Cloud?
Provides tools for securing microservices using OAuth2, JWT, and centralized security configuration.



36. What is SecurityFilterChain?
Defines the filter chain applied to HTTP requests for security purposes, customizable via Java config.



37. Difference between OAuth2 and JWT?
· 
OAuth2: Authorization framework
· 
JWT: Token format often used in OAuth2 for stateless authentication

38. How do you handle custom authentication?
Implement a custom AuthenticationProvider or UserDetailsService.

39. Different types of authentication mechanisms?
Form login, HTTP Basic, Digest, LDAP, OAuth2, JWT, SAML, API keys.


40. How to handle multi-tenant security?
Separate user stores per tenant or use claims/roles within tokens to restrict data access.



If you want, I can prepare a formatted document or slide deck with all these Q&As plus diagrams and code snippets for better study and interview prep. Just let me know!
Got it! I’ll prepare a detailed Markdown (.md) file covering all your questions, with:
· 
Well-structured explanations
· 
· 
Code snippets where relevant
· 
· 
Simple diagrams using Markdown syntax or Mermaid.js (if suitable)
· 
· 
Practice interview questions at the end of each major section
· 



I’ll start preparing it now and provide you with the full Markdown content here, ready to save as .md file on your side.



5. Different Design Patterns
Category	Patterns	Purpose
Creational	Singleton, Factory, Builder, Prototype	Object creation mechanisms
Structural	Adapter, Decorator, Proxy, Composite	Object composition & structure
Behavioral	Observer, Strategy, Command, Iterator	Object interaction and responsibility


6. If we initialize Date class object in a singleton, will the Date object be singleton too?
· 
No. The Date object inside singleton is just a field. Unless you make Date immutable and prevent modification, each call to its methods can change internal state.
· 
· 
Singleton guarantees a single instance of the class, not its mutable fields.
· 



7. What design pattern is used with async data update between different clients?
· 
Observer Pattern or Publish-Subscribe Pattern
· 
· 
Clients subscribe to updates and get notified asynchronously when data changes.
· 



8. Different Design Patterns (repeat)
See #5.



9. Return type of different List interface methods
Method	Return Type	Description
add(E e)	boolean	Adds element, returns success
get(int index)	E	Gets element at index
remove(int i)	E	Removes element at index
size()	int	Number of elements
iterator()	Iterator	Returns iterator over elements


10. What is the role of ZooKeeper?
· 
Provides distributed coordination such as configuration management, naming, synchronization.
· 
· 
Used in distributed systems (Kafka, Hadoop) for service discovery and cluster state management.
· 



11. How to handle failure retry in Kafka?
· 
Configure consumer retries using retry.backoff.ms and max.poll.interval.ms.
· 
· 
Use Dead Letter Queues (DLQ) to handle messages failing repeatedly.
· 
· 
Use idempotent producers to
· 
 
Absolutely! Here’s a structured, detailed, and interview-focused answer sheet for your diverse set of Java, Spring Boot, Kafka, microservices, and design patterns questions. Each answer is crafted for clarity, easy studying, real-world usage, and includes code snippets or examples where appropriate.



Java, Spring Boot & Microservices Interview Questions & Answers



2. What is the difference between execution in Executor Framework?
· 
execute(Runnable): Executes a Runnable task, returns void. No result returned.
· 
· 
submit(Callable/Runnable): Submits a task and returns a Future representing pending completion and possible result. Supports cancellation and result retrieval.
· 



3. What is a BlockingQueue?
A thread-safe queue that blocks threads trying to add when full or remove when empty. Used in producer-consumer scenarios.
Example: ArrayBlockingQueue, LinkedBlockingQueue.



4. How do we know thread pool is exhausted or has empty threads?
· 
Using ThreadPoolExecutor metrics:
· 
o 
getActiveCount() shows current active threads.
o 
o 
getPoolSize() shows current thread count.
o 
· 
If getActiveCount() == getMaximumPoolSize(), pool is exhausted.
· 



5. Different design patterns?
· 
Creational: Singleton, Factory, Builder, Prototype
· 
· 
Structural: Adapter, Decorator, Proxy, Composite
· 
· 
Behavioral: Observer, Strategy, Command, Iterator
· 



6. If you initialize a Date class object in a singleton, will the Date object be singleton too?
No. Singleton means only one instance of the Singleton class exists. But the Date object inside it is a separate object. Unless you restrict it, Date can be mutable and changed.



7. What design pattern is used with async data update between different clients?
Observer Pattern (Pub-Sub): Clients subscribe to updates; when data changes, all subscribers get notified asynchronously.



8. Different design patterns (repeat of 5)
See answer 5.





10. What is the role of ZooKeeper?
ZooKeeper provides distributed coordination, configuration management, and naming services, often used for service discovery in microservices or Kafka cluster management.



11. How to handle failure retry in Kafka?
· 
Configure consumer retry logic with max.poll.interval.ms, retry.backoff.ms.
· 
· 
Use Dead Letter Queues (DLQ) to capture failed messages.
· 
· 
Implement idempotent producers to avoid duplication.
· 



12. Spring Boot Annotations
· 
@SpringBootApplication – main config
· 
· 
@RestController – REST endpoints
· 
· 
@Autowired – dependency injection
· 
· 
@Service, @Repository, @Component – stereotype annotations
· 
· 
@Configuration – config class
· 
· 
@EnableAutoConfiguration – auto setup
· 



15. Pagination vs JPA Repository
· 
Pagination: Divides large result sets into smaller pages, improves performance.
· 
· 
JPA Repository supports pagination via Pageable interface and methods returning Page<T>.
· 



16. Different Design Patterns (repeat again)
Refer to 5.



17. Database-related Questions: Cursor, Normalization, Query
· 
Cursor: Controls row-by-row processing in DB queries.
· 
· 
Normalization: Process to reduce redundancy by organizing DB tables (1NF, 2NF, 3NF).
· 
· 
Query: SQL command to retrieve or manipulate data.
· 



18. Spring Security – Login Process / How to Implement Login & Spring Boot Version
· 
Spring Security intercepts login requests, authenticates users using AuthenticationManager, and manages sessions or tokens.
· 
· 
Use Spring Boot 2.x or 3.x (latest stable) for better security and features.
· 
· 
Implement login via formLogin() or JWT for REST APIs.
· 



19. Annotations (Java / Spring)
Common ones include @Override, @Deprecated, @Transactional, @RequestMapping, @Component, etc.



20. Database Connections
· 
Managed via DataSource, connection pools (HikariCP).
· 
· 
Configure in application.properties with URL, username, password, driver.
· 


28. Which Spring Boot version worked on?
Specify e.g., Spring Boot 2.7, 3.0.



29. How do you claim you worked on microservices?
Mention usage of microservice architecture, REST APIs, Spring Cloud, service discovery (Eureka), API Gateway, Docker/Kubernetes.



30. Wallet service in Java Spring Boot?
Design a microservice managing wallet balance, transactions, and updates, exposed as REST APIs with DB persistence.



31. If 25 connections are required, how to set up in microservices?
Configure connection pool (HikariCP) with max pool size 25. Use Kubernetes Horizontal Pod Autoscaling for scaling services.



32. What is Dialect?
In Hibernate/JPA, a dialect defines SQL variations for specific databases (MySQLDialect, OracleDialect).



33. Return type of Void method?
void means no return value. In generics, Void can be used as a placeholder.



36. Explain Pagination concept with example
Dividing large results into pages using offset and limit or Spring Data’s Pageable.
Example:
Page<User> usersPage = userRepository.findAll(PageRequest.of(0, 10));



37. Explain Kubernetes config
Kubernetes config files define pods, deployments, services with YAML files specifying replicas, images, ports.



38. You have to call system A, how to call system B using service line?
Implement service-to-service communication, usually REST API calls or message queues between microservices.



39. What is the purpose of records in Java? Have you used them?
Records are immutable data carriers introduced in Java 14+, reducing boilerplate.
public record User(String name, int age) { }



40. What is starter io dependency in Spring?
Spring Boot Starters are dependency descriptors that aggregate common dependencies for modules like web, data, security.



If you want, I can prepare this in a nicely formatted PDF or Markdown file with code snippets, diagrams, and practice interview questions. Let me know!
 
